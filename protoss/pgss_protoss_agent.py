"""
Main Author of all PYSC2 Related Code:   Frederick Qiu
Neural Network Optimizer (not in file):  Evan Troop
Machine Learning Input and Organization: John Zhuang, Benjamin Chen, Amir Saman Naseri

Received much help from Steven Brown in the form of discord and basic tutorials:
https://itnext.io/build-a-zerg-bot-with-pysc2-2-0-2self.SCREEN_DIM - 1375d2f58e
https://itnext.io/how-to-locate-and-select-units-in-pysc2-2bb1c81f2ad3
"""

from pysc2.agents import base_agent
from pysc2.env import sc2_env
from pysc2.lib import actions, features, units
from absl import app
import random, math
from sklearn.cluster import KMeans
import csv


class ProtossAgent(base_agent.BaseAgent):
    
    ###########
    #ADD ERROR CHECKING FOR COORDS BECAUSE UNITS CAN RUN OFF SCREEN WHILE SELECTED IF CHASING ENEMIES!!!!!
    ###########
#Larva
#Drone
#Zergling
#Queen
#Hydralisk
#Baneling

#Roach
#Infestor
#Mutalisk
#Nydus Worm
#Ultralisk
#Brood Lord
#Swarm Host
#Viper

#Overlord
#Overseer
#Corruptor 
    
    #IDK MAN
    
    
    #res = []
    
    SCREEN_DIM = 96
    MINIMAP_DIM = 64
    ARMY_ATTACK_THRESHOLD = 25
    
    ARMY_RATIO = {
            "Zealot": 4,
            "Stalker": 10,
            "Sentry": 4,
            "Observer": 1,
            "Immortal": 3,
            "Templar": 3,
            "Total": 25
            }
    
    step_number = 0
    action_number = 1
    sub_action_number = 0
    number_of_bases = 1
    time_until_nexus = 2000
    time_supply_needed = 250
    time_idle_needed = 250
    supply_needed = True
    idle_needed = True
    build_pylon = False
    stop_worker_production = False
    minerals_filled = False
    
    resource_locations = []
    main_base_camera = [0, 0]
    natural_base_camera = [0, 0]
    army_rally_camera = [0, 0]
    main_enemy_base = [0, 0]
    possible_enemy_base = [0, 0]
    nexus_location = [0, 0]
    build_lean = [0, 0]
    first_pylon_location = [0, 0]
    
    geysers = []
    
    
    
    #Initializes variables
    def __init__(self):
        super(ProtossAgent, self).__init__()
    
    #Checks if selected unit is of the correct type
    def unit_type_is_selected(self, obs, unit_type):
        if (len(obs.observation.single_select) > 0 and
                obs.observation.single_select[0].unit_type == unit_type):
            return True    
        if (len(obs.observation.multi_select) > 0 and
                obs.observation.multi_select[0].unit_type == unit_type):
            return True    
        return False
    
    #Adds all units of the same type on screen to an array
    def get_units_by_type(self, obs, unit_type):
        return [unit for unit in obs.observation.feature_units
                        if unit.unit_type == unit_type]
    
    #Checks if selected unit can execute an action
    def can_do(self, obs, action):
        return action in obs.observation.available_actions
    
    #Generates a random location on the screen
    def random_location(self):
        return [random.randint(0, self.SCREEN_DIM - 1), random.randint(0, 71)]
    
    #Find the distance between 2 points
    def get_distance(self, x1, y1, x2, y2):
        return math.sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))
    
    #Calculate the affinity generated by a specific unit for a location
    def get_affinity(self, obs, control_group, x, y):
        affinity = 0
        all_effects = obs.observation.feature_screen.effects
        all_units = obs.observation.feature_units
        for i in range(len(all_effects)):
            for j in range(len(all_effects)):
                if all_effects[i][j] != 0:
                    ###########SOME_FUNCTION#########(all_effects[i])
                    distance = self.get_distance(x, y, i, j)
                    value = 15
                    if distance < 16 and all_effects[i][j] == 2:
                        affinity+=value
                    elif distance < 12 and all_effects[i][j] == 10:
                        affinity-=(value*2)
                    elif distance < 8 and (all_effects[i][j] == 1 or all_effects[i][j] == 11):
                        affinity-=(value*4)
        for i in range(len(all_units)):
            ###########SOME_FUNCTION#########(control_group, all_units[i])
            distance = self.get_distance(x, y, all_units[i].x, all_units[i].y)
            if all_units[i].alliance == 4:
                value = 5
                if control_group == 3 or control_group == 6:
                    affinity+=(value * (1 / (1 + (distance/4 - 7)**2) - 1 / (1 + math.exp(distance - 24))))
                elif control_group == 2:
                    affinity+=(value * (1 / (1 + (distance/4 - 5)**2) - 1 / (1 + math.exp(distance - 16))))
                elif control_group == 5:
                    affinity+=(value * (1 / (1 + (distance/4 - 3)**2) - 1 / (1 + math.exp(distance - 8))))
            elif control_group != 5 and (all_units[i].unit_type == 82 or all_units[i].unit_type == 83):
                value = 1
                if control_group == 4:
                    affinity+=(value * (1 / (1 + math.exp(2*distance - 16))))
        return affinity
    
    #Calculate the affinities for moves and return the highest affinity
    def get_optimal_move(self, obs, control_group, x, y):
        location = [0, 0]
        highest_affinity = -1000
        x = min(max(int(round(x)), 0), 95)
        y = min(max(int(round(y)), 0), 95)
        for i in range(0, self.SCREEN_DIM - 1, 3):
            for j in range(0, self.SCREEN_DIM - 1, 3):
                distance = self.get_distance(x, y, i, j)
                if distance <= 6 and abs(obs.observation.feature_screen.height_map[i][j] - obs.observation.feature_screen.height_map[x][y]) < 5:
                    affinity = self.get_affinity(obs, control_group, i, j) / (1 + math.exp(distance/4 - 3))
                    if affinity > highest_affinity:
                        highest_affinity = affinity
                        location = [i, j]
        return location
        
    
    
    
        
    #Returns an action to the game at the end of every step
    def step(self, obs):
        super(ProtossAgent, self).step(obs)
        
        #Use K-Means clustering to find center of masses of the various resource clusters
        if obs.first():
            resources_y, resources_x = (obs.observation.feature_minimap.player_relative == features.PlayerRelative.NEUTRAL).nonzero()
            number_of_clusters = int(math.ceil(len(resources_y) / 16))
            resources = []
            for i in range(0, len(resources_y)):
                resources.append((resources_x[i], resources_y[i]))
            kmeans = KMeans(n_clusters = number_of_clusters)
            kmeans.fit(resources)
            for i in range(number_of_clusters):
                self.resource_locations.append((kmeans.cluster_centers_[i][0], kmeans.cluster_centers_[i][1]))
            for i in range(number_of_clusters):
                if self.resource_locations[i][0] < self.MINIMAP_DIM / 2:
                    if self.resource_locations[i][1] < self.MINIMAP_DIM / 2:
                        self.resource_locations[i] = (int(round(self.resource_locations[i][0])) + 3, int(round(self.resource_locations[i][1])) + 3)
                    else:
                        self.resource_locations[i] = (int(round(self.resource_locations[i][0])) + 3, int(round(self.resource_locations[i][1])) - 3)
                else:
                    if self.resource_locations[i][1] < self.MINIMAP_DIM / 2:
                        self.resource_locations[i] = (int(round(self.resource_locations[i][0])) - 3, int(round(self.resource_locations[i][1])) + 3)
                    else:
                        self.resource_locations[i] = (int(round(self.resource_locations[i][0])) - 3, int(round(self.resource_locations[i][1])) - 3)
                    
            #ONLY FOR SIMPLE64 MAP        
            player_y, player_x = (obs.observation.feature_minimap.player_relative == features.PlayerRelative.SELF).nonzero()
            xmean = player_x.mean()
            ymean = player_y.mean()
            if xmean < self.MINIMAP_DIM / 2:
                self.build_lean[0] = -1
            else:
                self.build_lean[0] = 1
            if ymean < self.MINIMAP_DIM / 2:
                self.build_lean[1] = -1
            else:
                self.build_lean[1] = 1
            for i in range(number_of_clusters):
                if abs(self.resource_locations[i][1] - ymean) < 10:
                    if abs(self.resource_locations[i][0] - xmean) < 10:
                        self.main_base_camera[0] = self.resource_locations[i][0] - self.build_lean[0]
                        self.main_base_camera[1] = self.resource_locations[i][1] + self.build_lean[1]
                    else:
                        self.natural_base_camera[0] = self.resource_locations[i][0] - self.build_lean[0]
                        self.natural_base_camera[1] = self.resource_locations[i][1] + self.build_lean[1]
                        self.army_rally_camera[0] = self.resource_locations[i][0] + 4*self.build_lean[0]
                        self.army_rally_camera[1] = self.resource_locations[i][1] - 4*self.build_lean[1]
                else:
                    if abs(self.resource_locations[i][0] - xmean) > 10:
                        self.main_enemy_base = self.resource_locations[i]
                    else:
                        self.possible_enemy_base = self.resource_locations[i]
        
        
        
        
        
        nexi = self.get_units_by_type(obs, units.Protoss.Nexus)
        if len(nexi) == 1:
            nexus = nexi[0]
            
        probes = self.get_units_by_type(obs, units.Protoss.Probe)
        minerals = self.get_units_by_type(obs, units.Neutral.MineralField)
        assimilators = self.get_units_by_type(obs, units.Protoss.Assimilator)
        pylons = self.get_units_by_type(obs, units.Protoss.Pylon)
        
        gateways = self.get_units_by_type(obs, units.Protoss.Gateway)
        warpgates = self.get_units_by_type(obs, units.Protoss.WarpGate)
        facilities = self.get_units_by_type(obs, units.Protoss.RoboticsFacility)
        
        forges = self.get_units_by_type(obs, units.Protoss.Forge)
        cores = self.get_units_by_type(obs, units.Protoss.CyberneticsCore)
        councils = self.get_units_by_type(obs, units.Protoss.TwilightCouncil)
        archives = self.get_units_by_type(obs, units.Protoss.TemplarArchive)
        
        zealots = self.get_units_by_type(obs, units.Protoss.Zealot)
        stalkers = self.get_units_by_type(obs, units.Protoss.Stalker)
        sentries = self.get_units_by_type(obs, units.Protoss.Sentry)
        observers = self.get_units_by_type(obs, units.Protoss.Observer)
        immortals = self.get_units_by_type(obs, units.Protoss.Immortal)
        templars = self.get_units_by_type(obs, units.Protoss.HighTemplar)
        
        
        
        
        self.sub_action_number+=1
        if self.number_of_bases == 2 and self.time_until_nexus > 0:
            self.time_until_nexus-=1
        if self.idle_needed == False:
            self.time_idle_needed = 0
        else:
            self.time_idle_needed+=1
        if self.supply_needed == False:
            self.time_supply_needed = 0
        else:
            self.time_supply_needed+=1
           
            
            
        """if self.sub_action_number < 10:
            return actions.FUNCTIONS.move_camera((self.main_base_camera[0] - 8*self.build_lean[0], self.main_base_camera[1]))
        
        self.res = obs.observation.feature_screen.height_map
        
        csvfile = "height_map_sample.csv"
        
        #Assuming res is a flat list
        with open(csvfile, "w") as output:
            writer = csv.writer(output, lineterminator='\n')
            for val in self.res:
                writer.writerow([val])    
        
        #Assuming res is a list of lists
        with open(csvfile, "w") as output:
            writer = csv.writer(output, lineterminator='\n')
            writer.writerows(self.res)
            print("nice")
        
        exit()"""
        
        
        print(str(self.action_number) + " " + str(self.sub_action_number))
        
        
        #Center camera on and select the main base, rally probes to correct resources, train probes
        if self.action_number == 1:
            
            if self.sub_action_number == 2:
                return actions.FUNCTIONS.move_camera(self.main_base_camera)
            
            if self.sub_action_number == 4:
                if len(self.geysers) == 0:
                    self.geysers = self.get_units_by_type(obs, units.Neutral.VespeneGeyser)
                if self.number_of_bases == 1 and len(nexi) > 0:
                    self.nexus_location[0] = nexus.x
                    self.nexus_location[1] = nexus.y
                if len(nexi) > 0:
                    if self.nexus_location[0] >= 0 and self.nexus_location[0] <= self.SCREEN_DIM - 1 and self.nexus_location[1] >= 0 and self.nexus_location[1] <= self.SCREEN_DIM - 1:
                        return actions.FUNCTIONS.select_point("select", self.nexus_location)
            
            if self.sub_action_number == 5:
                if self.unit_type_is_selected(obs, units.Protoss.Nexus):
                    if self.can_do(obs, actions.FUNCTIONS.select_idle_worker.id):
                        self.idle_needed = False
                    else:
                        self.idle_needed = True
                        self.minerals_filled == False
                        if self.time_idle_needed > 250:
                            return actions.FUNCTIONS.Rally_Workers_screen("now", (48, 48))
                    if nexus.assigned_harvesters < nexus.ideal_harvesters:
                        return actions.FUNCTIONS.Rally_Workers_screen("now", (minerals[0].x, minerals[0].y))
                    for i in range(len(assimilators)):
                        if assimilators[i].assigned_harvesters < assimilators[i].ideal_harvesters and assimilators[i].ideal_harvesters != 0:
                            return actions.FUNCTIONS.Rally_Workers_screen("now", (assimilators[i].x, assimilators[i].y))
                    if self.number_of_bases == 1 or self.minerals_filled:
                        if self.can_do(obs, actions.FUNCTIONS.Cancel_Last_quick.id):
                            return actions.FUNCTIONS.Cancel_Last_quick("now")
                            
            if self.sub_action_number == 6:
                if self.number_of_bases == 1:
                    self.sub_action_number = 0
                    self.action_number = 2
                if self.unit_type_is_selected(obs, units.Protoss.Nexus):
                    if len(obs.observation.build_queue) <= 1:
                        if self.can_do(obs, actions.FUNCTIONS.Train_Probe_quick.id):
                            return actions.FUNCTIONS.Train_Probe_quick("now")
            
            if self.sub_action_number == 8:
                return actions.FUNCTIONS.move_camera(self.natural_base_camera)
            
            if self.sub_action_number == 10:
                self.sub_action_number = 0
                self.action_number = 2
                if self.unit_type_is_selected(obs, units.Protoss.Nexus):
                    if len(minerals) > 0:
                        return actions.FUNCTIONS.Rally_Workers_screen("now", (minerals[0].x, minerals[0].y))
                
                
        #Select idle worker and center camera on main base, build assimilators and pylons at main base, build pylons by natural expansion if necessary
        if self.action_number == 2:
            
            if self.sub_action_number == 1:
                if self.can_do(obs, actions.FUNCTIONS.select_idle_worker.id):
                    return actions.FUNCTIONS.select_idle_worker("select")
            
            if self.sub_action_number == 3:
                return actions.FUNCTIONS.move_camera(self.main_base_camera)
                                    
            if self.sub_action_number == 5:
                if len(pylons) > 0 and len(assimilators) < len(self.geysers):
                    if self.unit_type_is_selected(obs, units.Protoss.Probe):
                        if self.can_do(obs, actions.FUNCTIONS.Build_Assimilator_screen.id):
                            return actions.FUNCTIONS.Build_Assimilator_screen("queued", (self.geysers[len(assimilators)].x, self.geysers[len(assimilators)].y))
            
            if self.sub_action_number == 6:
                if self.unit_type_is_selected(obs, units.Protoss.Probe):
                    if obs.observation.player.food_cap - obs.observation.player.food_used < 20 and obs.observation.player.food_cap != 200:
                        self.supply_needed = True
                        if self.time_supply_needed > 250:
                            if self.can_do(obs, actions.FUNCTIONS.Build_Pylon_screen.id):
                                self.supply_needed = False
                                if len(pylons) == 0:
                                    unit_type = obs.observation["feature_screen"][features.SCREEN_FEATURES.unit_type.index]
                                    mineral_y, mineral_x = (unit_type == units.Neutral.MineralField).nonzero()
                                    x = 2*nexus.x - int(round(mineral_x.mean())) - 5*self.build_lean[0]
                                    y = 2*nexus.y - int(round(mineral_y.mean())) - 5*self.build_lean[1]
                                    self.first_pylon_location[0] = x
                                    self.first_pylon_location[1] = y
                                    return actions.FUNCTIONS.Build_Pylon_screen("queued", self.first_pylon_location)
                                elif len(pylons) == 1:
                                    return actions.FUNCTIONS.Build_Pylon_screen("queued", (self.first_pylon_location[0] + self.build_lean[0]*35, self.first_pylon_location[1]))
                                elif len(pylons) == 2:
                                    return actions.FUNCTIONS.Build_Pylon_screen("queued", (self.first_pylon_location[0], self.first_pylon_location[1] + self.build_lean[1]*35))
                                else:
                                    self.build_pylon = True
                                    return actions.FUNCTIONS.move_camera(self.natural_base_camera)
                                    
            if self.sub_action_number == 8:
                if (len(obs.observation.last_actions) > 0 and obs.observation.last_actions[0] == 70) or self.build_pylon == False:
                    self.build_pylon = False
                    self.sub_action_number = 0
                    if self.time_until_nexus == 0:
                        self.action_number = 3
                    elif obs.observation.player.minerals > 550 and self.number_of_bases == 1:
                        self.action_number = 10
                    else:
                        self.action_number = 4
                else:
                    self.sub_action_number-=1
                if self.build_pylon:
                    if random.randint(0, 1) == 0:
                        if self.build_lean[0] == -1:
                            return actions.FUNCTIONS.Build_Pylon_screen("queued", (random.randint(0, 32), random.randint(0, 55)))
                        else:
                            return actions.FUNCTIONS.Build_Pylon_screen("queued", (random.randint(63, self.SCREEN_DIM - 1), random.randint(16, 71)))
                    else:
                        if self.build_lean[1] == -1:
                            return actions.FUNCTIONS.Build_Pylon_screen("queued", (random.randint(16, self.SCREEN_DIM - 1), random.randint(63, 71)))
                        else:
                            return actions.FUNCTIONS.Build_Pylon_screen("queued", (random.randint(0, 79), random.randint(0, 32)))
                
                
        #Center camera on natural expansion, rally probes to correct resources, train probes
        if self.action_number == 3:
            
            if self.sub_action_number == 2:
                return actions.FUNCTIONS.move_camera(self.natural_base_camera)
            
            if self.sub_action_number == 4:
                return actions.FUNCTIONS.select_point("select", (48, 48))
                
            if self.sub_action_number == 5:
                if self.unit_type_is_selected(obs, units.Protoss.Nexus):
                    if nexus.assigned_harvesters < nexus.ideal_harvesters:
                        return actions.FUNCTIONS.Rally_Workers_screen("now", (minerals[0].x, minerals[0].y))
                    else:
                        self.minerals_filled = True
                    for i in range(len(assimilators)):
                        if assimilators[i].assigned_harvesters < assimilators[i].ideal_harvesters and assimilators[i].ideal_harvesters != 0:
                            return actions.FUNCTIONS.Rally_Workers_screen("now", (assimilators[i].x, assimilators[i].y))
                    if self.can_do(obs, actions.FUNCTIONS.Cancel_Last_quick.id):
                        self.stop_worker_production = True
                        return actions.FUNCTIONS.Cancel_Last_quick("now")
                            
            if self.sub_action_number == 6:
                self.sub_action_number = 0
                self.action_number = 4
                if self.unit_type_is_selected(obs, units.Protoss.Nexus):
                    if len(obs.observation.build_queue) <= 1:
                        if self.can_do(obs, actions.FUNCTIONS.Train_Probe_quick.id):
                            return actions.FUNCTIONS.Train_Probe_quick("now")
                            
        
        #Center camera on main base and construct combat buildings
        if self.action_number == 4:
            
            if self.sub_action_number == 1:
                if self.can_do(obs, actions.FUNCTIONS.select_idle_worker.id):
                    return actions.FUNCTIONS.select_idle_worker("select")
            
            if self.sub_action_number == 3:
                return actions.FUNCTIONS.move_camera(self.main_base_camera)
            
            if self.sub_action_number == 5:
                self.sub_action_number = 0
                self.action_number = 5
                if self.unit_type_is_selected(obs, units.Protoss.Probe):    
                    if len(gateways) < 1:
                        if self.can_do(obs, actions.FUNCTIONS.Build_Gateway_screen.id):
                            return actions.FUNCTIONS.Build_Gateway_screen("queued", self.random_location())
                    elif len(cores) < 1:
                        if self.can_do(obs, actions.FUNCTIONS.Build_CyberneticsCore_screen.id):
                            return actions.FUNCTIONS.Build_CyberneticsCore_screen("queued", self.random_location())
                    elif len(forges) < 1:
                        if self.can_do(obs, actions.FUNCTIONS.Build_Forge_screen.id):
                            return actions.FUNCTIONS.Build_Forge_screen("queued", self.random_location())
                    elif self.number_of_bases > 1:
                        if len(gateways) < 2:
                            if self.can_do(obs, actions.FUNCTIONS.Build_Gateway_screen.id):
                                return actions.FUNCTIONS.Build_Gateway_screen("queued", self.random_location())
                        elif len(facilities) < 1:
                            if self.can_do(obs, actions.FUNCTIONS.Build_RoboticsFacility_screen.id):
                                return actions.FUNCTIONS.Build_RoboticsFacility_screen("queued", self.random_location())
                        elif len(forges) < 2:
                            if self.can_do(obs, actions.FUNCTIONS.Build_Forge_screen.id):
                                return actions.FUNCTIONS.Build_Forge_screen("queued", self.random_location())
                        elif len(councils) < 1:
                            if self.can_do(obs, actions.FUNCTIONS.Build_TwilightCouncil_screen.id):
                                return actions.FUNCTIONS.Build_TwilightCouncil_screen("queued", self.random_location())
                        elif len(gateways) < 3:
                            if self.can_do(obs, actions.FUNCTIONS.Build_Gateway_screen.id):
                                return actions.FUNCTIONS.Build_Gateway_screen("queued", self.random_location())
                        elif len(archives) < 1:
                            if self.can_do(obs, actions.FUNCTIONS.Build_TemplarArchive_screen.id):
                                return actions.FUNCTIONS.Build_TemplarArchive_screen("queued", self.random_location())
                        elif len(facilities) < 2:
                            if self.can_do(obs, actions.FUNCTIONS.Build_RoboticsFacility_screen.id):
                                return actions.FUNCTIONS.Build_RoboticsFacility_screen("queued", self.random_location())
                        elif len(gateways) < 4:
                            if self.can_do(obs, actions.FUNCTIONS.Build_Gateway_screen.id):
                                return actions.FUNCTIONS.Build_Gateway_screen("queued", self.random_location())
                        
                        
        #Train units from gateway/warpgate
        if self.action_number == 5:
            
            if self.sub_action_number == 2:
                return actions.FUNCTIONS.move_camera(self.main_base_camera)
            
            if self.sub_action_number == 4:
                if len(gateways) > 0:
                    gateway = random.choice(gateways)
                    if gateway.x >= 0 and gateway.x <= self.SCREEN_DIM - 1 and gateway.y >= 0 and gateway.y <= self.SCREEN_DIM - 1:
                        return actions.FUNCTIONS.select_point("select", (gateway.x, gateway.y))
            
            if self.sub_action_number == 6:
                return actions.FUNCTIONS.move_camera(self.army_rally_camera)
                
            if self.sub_action_number == 8:
                if self.unit_type_is_selected(obs, units.Protoss.Gateway):
                    return actions.FUNCTIONS.Rally_Units_screen("now", (48, 48))
            
            if self.sub_action_number == 9:
                if self.unit_type_is_selected(obs, units.Protoss.Gateway):
                    if len(obs.observation.build_queue) < 2:
                        if len(stalkers) / (obs.observation.player.army_count + 1) < self.ARMY_RATIO["Stalker"] / self.ARMY_RATIO["Total"]:
                            if self.can_do(obs, actions.FUNCTIONS.Train_Stalker_quick.id):
                                return actions.FUNCTIONS.Train_Stalker_quick("now")
                        if len(sentries) / (obs.observation.player.army_count + 1) < self.ARMY_RATIO["Sentry"] / self.ARMY_RATIO["Total"]:
                            if self.can_do(obs, actions.FUNCTIONS.Train_Sentry_quick.id):
                                return actions.FUNCTIONS.Train_Sentry_quick("now")
                        if len(templars) / (obs.observation.player.army_count + 1) < self.ARMY_RATIO["Templar"] / self.ARMY_RATIO["Total"]:
                            if self.can_do(obs, actions.FUNCTIONS.Train_HighTemplar_quick.id):
                                return actions.FUNCTIONS.Train_HighTemplar_quick("now")
                        if self.can_do(obs, actions.FUNCTIONS.Train_Zealot_quick.id):
                            return actions.FUNCTIONS.Train_Zealot_quick("now")
            
            if self.sub_action_number == 11:
                return actions.FUNCTIONS.move_camera(self.main_base_camera)
                            
            if self.sub_action_number == 13:
                if len(facilities) > 0:
                    facility = random.choice(facilities)
                    if facility.x >= 0 and facility.x <= self.SCREEN_DIM - 1 and facility.y >= 0 and facility.y <= self.SCREEN_DIM - 1:
                        return actions.FUNCTIONS.select_point("select", (facility.x, facility.y))
            
            if self.sub_action_number == 15:
                return actions.FUNCTIONS.move_camera(self.army_rally_camera)
            
            if self.sub_action_number == 17:
                if self.unit_type_is_selected(obs, units.Protoss.RoboticsFacility):
                    return actions.FUNCTIONS.Rally_Units_screen("now", (48, 48))
                
            if self.sub_action_number == 18:
                self.sub_action_number = 0
                self.action_number = 6
                if self.unit_type_is_selected(obs, units.Protoss.RoboticsFacility):
                    if len(obs.observation.build_queue) < 2:
                        if len(observers) / (obs.observation.player.army_count + 1) < self.ARMY_RATIO["Observer"] / self.ARMY_RATIO["Total"]:
                            if self.can_do(obs, actions.FUNCTIONS.Train_Observer_quick.id):
                                return actions.FUNCTIONS.Train_Observer_quick("now")
                        if self.can_do(obs, actions.FUNCTIONS.Train_Immortal_quick.id):
                            return actions.FUNCTIONS.Train_Immortal_quick("now")
                            
        
        #Select and add units to control groups and attack if enough units
        if self.action_number == 6:
            
            if self.sub_action_number == 2:
                return actions.FUNCTIONS.move_camera(self.army_rally_camera)
                
            if self.sub_action_number == 4:
                if self.can_do(obs, actions.FUNCTIONS.select_army.id):
                    return actions.FUNCTIONS.select_army("select")
            
            if self.sub_action_number == 5:
                return actions.FUNCTIONS.select_control_group("set", 1)
                
            if self.sub_action_number == 6:
                if len(stalkers) > 0:
                    stalker = random.choice(stalkers)
                    if stalker.x >= 0 and stalker.x < self.SCREEN_DIM and stalker.y >= 0 and stalker.y < self.SCREEN_DIM:
                        return actions.FUNCTIONS.select_point("select_all_type", (stalker.x, stalker.y))
            
            if self.sub_action_number == 7:
                if self.unit_type_is_selected(obs, units.Protoss.Stalker):
                    return actions.FUNCTIONS.select_control_group("append", 2)
                
            if self.sub_action_number == 8:
                if len(sentries) > 0:
                    sentry = random.choice(sentries)
                    if sentry.x >= 0 and sentry.x < self.SCREEN_DIM and sentry.y >= 0 and sentry.y < self.SCREEN_DIM:
                        return actions.FUNCTIONS.select_point("select_all_type", (sentry.x, sentry.y))
            
            if self.sub_action_number == 9:
                if self.unit_type_is_selected(obs, units.Protoss.Sentry):
                    return actions.FUNCTIONS.select_control_group("append", 3)
                
            if self.sub_action_number == 10:
                if len(observers) > 0:
                    observer = random.choice(observers)
                    if observer.x >= 0 and observer.x < self.SCREEN_DIM and observer.y >= 0 and observer.y < self.SCREEN_DIM:
                        return actions.FUNCTIONS.select_point("select_all_type", (observer.x, observer.y))
            
            if self.sub_action_number == 11:
                if self.unit_type_is_selected(obs, units.Protoss.Observer):
                    return actions.FUNCTIONS.select_control_group("append", 4)
                
            if self.sub_action_number == 12:
                if len(immortals) > 0:
                    immortal = random.choice(immortals)
                    if immortal.x >= 0 and immortal.x < self.SCREEN_DIM and immortal.y >= 0 and immortal.y < self.SCREEN_DIM:
                        return actions.FUNCTIONS.select_point("select_all_type", (immortal.x, immortal.y))
            
            if self.sub_action_number == 13:
                if self.unit_type_is_selected(obs, units.Protoss.Immortal):
                    return actions.FUNCTIONS.select_control_group("append", 5)
                
            if self.sub_action_number == 14:
                if len(templars) > 0:
                    templar = random.choice(templars)
                    if templar.x >= 0 and templar.x < self.SCREEN_DIM and templar.y >= 0 and templar.y < self.SCREEN_DIM:
                        return actions.FUNCTIONS.select_point("select_all_type", (templar.x, templar.y))
            
            if self.sub_action_number == 15:
                self.sub_action_number = 0
                self.action_number = 7
                if self.unit_type_is_selected(obs, units.Protoss.HighTemplar):
                    return actions.FUNCTIONS.select_control_group("append", 6)
                
            
        #Send army to rekt enemy ezzzzzzzz
        if self.action_number == 7:
            
            if self.sub_action_number == 1:
                return actions.FUNCTIONS.select_control_group("recall", 1)
            
            if self.sub_action_number == 3:
                pixels_y, pixels_x = (obs.observation.feature_minimap.selected == features.PlayerRelative.SELF).nonzero()
                pixels = []
                for i in range(0, len(pixels_y)):
                    pixels.append((pixels_x[i], pixels_y[i]))
                kmeans = KMeans(n_clusters = 1)
                kmeans.fit(pixels)
                return actions.FUNCTIONS.move_camera(kmeans.cluster_centers_[0])
            
            if self.sub_action_number == 5:
                pixels_y, pixels_x = (obs.observation.feature_minimap.selected == features.PlayerRelative.SELF).nonzero()
                pixels = []
                for i in range(0, len(pixels_y)):
                    pixels.append((pixels_x[i], pixels_y[i]))
                    print(pixels)
                kmeans = KMeans(n_clusters = 1)
                kmeans.fit(pixels)
                #if abs(kmeans.cluster_centers_[0][0] - self.possible_enemy_base[0]) > 2 and abs(kmeans.cluster_centers_[0][1] - self.possible_enemy_base[1]) > 2:
                 #   return actions.FUNCTIONS.Attack_minimap("now", self.possible_enemy_base)
                micromanage = False
                for i in range(len(obs.observation.feature_units)):
                    if obs.observation.feature_units[i].alliance == 4 and obs.observation.feature_units[i].unit_type != units.Zerg.ChangelingZealot:
                        micromanage = True
                if micromanage == False and obs.observation.control_groups[1][1] >= self.ARMY_ATTACK_THRESHOLD:
                    self.sub_action_number = 0
                    self.action_number = 1
                    if self.can_do(obs, actions.FUNCTIONS.Attack_minimap.id):
                        return actions.FUNCTIONS.Attack_minimap("now", self.main_enemy_base)
                
            if self.sub_action_number == 6:
                return actions.FUNCTIONS.select_control_group("recall", 2)
            
            if self.sub_action_number == 7:
                if len(stalkers) > 0:
                    stalkers_x = []
                    stalkers_y = []
                    for i in range(len(stalkers)):
                        stalkers_x.append(stalkers[i].x)
                        stalkers_y.append(stalkers[i].y)
                    stalkers_y = sum(stalkers_y) / len(stalkers_y)
                    stalkers_x = sum(stalkers_x) / len(stalkers_x)
                    optimal_move = self.get_optimal_move(obs, 2, stalkers_x, stalkers_y)
                    if self.unit_type_is_selected(obs, units.Protoss.Stalker):
                        return actions.FUNCTIONS.Move_screen("now", optimal_move)
            
            if self.sub_action_number == 8:
                return actions.FUNCTIONS.select_control_group("recall", 3)
            
            if self.sub_action_number == 9:
                if len(sentries) > 0:
                    sentries_x = []
                    sentries_y = []
                    for i in range(len(sentries)):
                        sentries_x.append(sentries[i].x)
                        sentries_y.append(sentries[i].y)
                    sentries_y = sum(sentries_y) / len(sentries_y)
                    sentries_x = sum(sentries_x) / len(sentries_x)
                    optimal_move = self.get_optimal_move(obs, 2, sentries_x, sentries_y)
                    if self.unit_type_is_selected(obs, units.Protoss.Sentry):
                        return actions.FUNCTIONS.Move_screen("now", optimal_move)
            
            if self.sub_action_number == 10:
                return actions.FUNCTIONS.select_control_group("recall", 4)
            
            if self.sub_action_number == 11:
                if len(observers) > 0:
                    observers_x = []
                    observers_y = []
                    for i in range(len(observers)):
                        observers_x.append(observers[i].x)
                        observers_y.append(observers[i].y)
                    observers_y = sum(observers_y) / len(observers_y)
                    observers_x = sum(observers_x) / len(observers_x)
                    optimal_move = self.get_optimal_move(obs, 2, observers_x, observers_y)
                    if self.unit_type_is_selected(obs, units.Protoss.Observer):
                        return actions.FUNCTIONS.Move_screen("now", optimal_move)
            
            if self.sub_action_number == 12:
                return actions.FUNCTIONS.select_control_group("recall", 5)
            
            if self.sub_action_number == 13:
                if len(immortals) > 0:
                    immortals_x = []
                    immortals_y = []
                    for i in range(len(immortals)):
                        immortals_x.append(immortals[i].x)
                        immortals_y.append(immortals[i].y)
                    immortals_y = sum(immortals_y) / len(immortals_y)
                    immortals_x = sum(immortals_x) / len(immortals_x)
                    optimal_move = self.get_optimal_move(obs, 2, immortals_x, immortals_y)
                    if self.unit_type_is_selected(obs, units.Protoss.Immortal):
                        return actions.FUNCTIONS.Move_screen("now", optimal_move)
            
            if self.sub_action_number == 14:
                return actions.FUNCTIONS.select_control_group("recall", 6)
            
            if self.sub_action_number == 15:
                self.sub_action_number = 0
                if obs.observation.control_groups[1][1] < self.ARMY_ATTACK_THRESHOLD:#############
                    self.action_number = 1
                if len(templars) > 0:
                    templars_x = []
                    templars_y = []
                    for i in range(len(templars)):
                        templars_x.append(templars[i].x)
                        templars_y.append(templars[i].y)
                    templars_y = sum(templars_y) / len(templars_y)
                    templars_x = sum(templars_x) / len(templars_x)
                    optimal_move = self.get_optimal_move(obs, 2, templars_x, templars_y)
                    if self.unit_type_is_selected(obs, units.Protoss.HighTemplar):
                        return actions.FUNCTIONS.Move_screen("now", optimal_move)
        
        
        #Select worker and center camera on natural expansion, build nexus and assimilators
        if self.action_number == 10:
            
            if self.sub_action_number == 1:
                self.number_of_bases+=1
                if self.can_do(obs, actions.FUNCTIONS.select_idle_worker.id):
                    return actions.FUNCTIONS.select_idle_worker("select")
                    
            if self.sub_action_number == 3:
                return actions.FUNCTIONS.move_camera(self.natural_base_camera)
            
            if self.sub_action_number == 5:
                if self.unit_type_is_selected(obs, units.Protoss.Probe):
                    if self.can_do(obs, actions.FUNCTIONS.Build_Nexus_screen.id):
                        return actions.FUNCTIONS.Build_Nexus_screen("queued", (48, 48))
                
            if self.sub_action_number == 6:
                self.geysers = self.get_units_by_type(obs, units.Neutral.VespeneGeyser)
                if self.unit_type_is_selected(obs, units.Protoss.Probe):
                    if self.can_do(obs, actions.FUNCTIONS.Build_Assimilator_screen.id):
                        return actions.FUNCTIONS.Build_Assimilator_screen("queued", (self.geysers[0].x, self.geysers[0].y))
                
            if self.sub_action_number == 7:
                self.sub_action_number = 0
                self.action_number = 1
                if self.unit_type_is_selected(obs, units.Protoss.Probe):
                    if self.can_do(obs, actions.FUNCTIONS.Build_Assimilator_screen.id):
                        return actions.FUNCTIONS.Build_Assimilator_screen("queued", (self.geysers[1].x, self.geysers[1].y))
                            
                            
                            
        return actions.FUNCTIONS.no_op()





def main(unused_argv):
    agent = ProtossAgent()
    try:
        while True:
            with sc2_env.SC2Env(
                    #Map selection
                    map_name="Simple64",
                    #Players
                    players=[sc2_env.Agent(sc2_env.Race.protoss),
                             sc2_env.Bot(sc2_env.Race.zerg,
                                         sc2_env.Difficulty.medium_hard)],
                    #Define map and minimap size
                    agent_interface_format=features.AgentInterfaceFormat(
                            feature_dimensions=features.Dimensions(screen=96, minimap=64),
                            use_feature_units=True),
                    step_mul=1,
                    game_steps_per_episode=0,
                    visualize=True) as env:
                
                agent.setup(env.observation_spec(), env.action_spec())
                timesteps = env.reset()
                agent.reset()
                while True:
                    step_actions = [agent.step(timesteps[0])]
                    if timesteps[0].last():
                        break
                    timesteps = env.step(step_actions)
            
    except KeyboardInterrupt:
        pass
    
if __name__ == "__main__":
    app.run(main)